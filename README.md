# Завдання 1

За основу цього графу була взята частина моєї роботи на фінальному 
проєкті основ програмування Python, яка повністю базується на 
реальному проєкті. 

Результати (вершини) проєкту:

0.   Старт проєкту
1.   Огляд літератури та наявних готових алгоритмів
2.   Документ-порівняння ефективності роботи різних алгоритмів та їх вартості утримання.
3.   Набір тестових зображень і вручну видалених фонів у них (еталони відповідей)
4.   Підготовлений базовий користувацький інтерфейс для використання алгоритму
5.   Експериментальне порівняння ефективності топ 3 найкраших алгоритмів, а також їх комбінації.
6.   Імплементація затвердженого підходу у вигляді core-бібліотеки.
7.   Створений повноцінний веб-інтерфейс для інструменту.
8.   Підготовлений та створений веб-сервер під вимоги алгоритму та очікуване навантаження.
9.   Створений повноцінний API сервіс для використання основного функціоналу
10.  Затверджений алгоритм/підхід дотреновано на основі тестових зображень.
11.  Поєднані API та Core частини у бекенд.
12.  Поєднані бекенд та UI бібліотеки у єдиний веб-сервіс
13.  Веб-сервіс розміщений на веб-сервері та готовий до використання.
14.  Успішне фінальне тестування та апробація

Дії (ребра) графа:

Ребро  | Опис дії  |  Вартість (тривалість, робочі години)
-------------------|------------------|--------------------
0-1 | Виконати огляд наявної літератури, описів алгоритмів та відкритого коду | 20
1-2 | Cтворити пряме зпівставлення застосувань обраних алгоритмів із літератури а також оцінити їх вимоги та вартість (пряму чи опосередковану) | 20
0-3 | Підготовка банку валідаційних та тестових зображень із еталонами (вручну підготованими зображеннями із видаленим фоном) | 35
2-4 | Підготовка Jupyter інтерфейсу для швидкого тестування алгоритмів | 10
3-4 | Підключення тестових зображень до інтерфейсу | 10
4-5 | Виконання практичного порівння та аналізу обраних топ 3 алгоритмів та їх поєднання на основі банку тестових завдань та відбір найкращого підходу | 20
5-6 | Імплементація обраного алгоритму у вигляді core-бібліотеки | 20
4-10 | Дотренування на основі банку тестових завдань | 35
10-6 | Інтеграція змін до core-бібліотеки | 15
4-7 | Підготовка повноцінного веб-інтерфейсу для інструменту | 20
5-8 | Підготовка hardware інфраструктури та CI/CD пайплайнів | 20
6-9 | Підготовка API-сервісу, який робить доступними та зручними усі релевантні методи алгоритму | 30
9-11 | Підключення Core бібліотеки та API | 15
11-12 | Підключення бекенду | 10
7-12 | Підключення фронтенду до бекенду | 10
8-13 | Реалізація веб-серверу | 10
12-13 | Розміщення веб-сервісу на веб-сервері | 10
13-14 | Фінальне тестування | 40


# Завдання 2

Під час аналізу графу за допомогою алгоритмів Depth-First Search 
та Breadth-First Search відмічається наступний порядок обходження графа:

DFS: 0 1 2 4 5 6 9 11 12 13 14 8 10 7 3 
Час виконання DFS: 8.729996625334024e-05 секунд

BFS: 0 1 3 2 4 10 5 7 6 8 12 9 13 11 14 
Час виконання BFS: 5.879998207092285e-05 секунд

Такий порядок викликаний особливостями обходження алгоритмом - в глибину 
чи в ширину. За швидкістю виконання алгоритми подібні.


# Завдання 3

За алгоритмом Dijkstra, найкоротша відстань від 0 до 14 вузла склала 125.
Усі відстані: {0: 0, 1: 20, 2: 40, 3: 35, 4: 45, 5: 65, 6: 85, 7: 65, 8: 85, 9: 115, 10: 80, 11: 130, 12: 75, 13: 85, 14: 125}
